\documentclass[a4paper,12pt]{article}

% Pacotes para suporte a XeLaTeX e formatação
\usepackage{fontspec}
\usepackage{polyglossia}
\setmainlanguage{portuguese}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{float}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}

\geometry{left=3cm,right=2cm,top=3cm,bottom=2cm}

% Configuração de código
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegray},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

\title{\textbf{Relatório Técnico: Otimização de Escalonamento de Tarefas em Sistemas Computacionais}}
\author{Sistema de Gerenciamento de Tarefas}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Este documento apresenta uma análise detalhada do problema de gerenciamento de tarefas em sistemas computacionais com recursos limitados. Comparamos duas abordagens algorítmicas: uma heurística gulosa (\textit{Weighted Job Scheduling}) e uma solução exata baseada em Programação Dinâmica (\textit{0/1 Knapsack Problem}). O projeto destaca-se pela implementação manual de todos os algoritmos, incluindo o método de ordenação \textit{Quick Sort}, e pela análise crítica da otimização de desempenho.
\end{abstract}

\tableofcontents
\newpage

\section{Definição do Problema e Contextualização}

\subsection{Cenário: Centro de Processamento de Dados}
O sistema foi projetado para operar em um Centro de Processamento de Dados (CPD) com recursos computacionais finitos. O problema central é o **agendamento de tarefas** (Task Scheduling) sob restrição de tempo. Diferente de um sistema operacional de propósito geral que busca justiça (fairness), nosso objetivo é maximizar o **valor entregue** ao negócio.

Cada tarefa $i$ é definida pela tupla $(t_i, v_i, d_i)$, onde:
\begin{itemize}
    \item $t_i$ (Tempo): Custo de processamento.
    \item $v_i$ (Prioridade): Valor agregado pela conclusão da tarefa.
    \item $d_i$ (Prazo): Fator de urgência que influencia a prioridade dinâmica.
\end{itemize}

O problema é selecionar um subconjunto $S$ de tarefas tal que $\sum_{i \in S} t_i \leq T_{\text{total}}$ e $\sum_{i \in S} v_i$ seja máximo.

\subsection{O Dilema da Decisão}
O sistema deve decidir entre uma abordagem de resposta imediata (Guloso) ou uma garantia de otimalidade (Programação Dinâmica). A escolha impacta diretamente a eficiência operacional do CPD: algoritmos rápidos liberam o escalonador para outras funções, mas decisões subótimas desperdiçam ciclos de CPU com tarefas de menor valor.

\section{Implementação e Metodologia}

\subsection{Implementação Manual de Algoritmos}
Em conformidade com os requisitos do projeto, \textbf{todos os algoritmos principais foram implementados manualmente}, sem o uso de bibliotecas de otimização ou funções de ordenação nativas (como \texttt{Collections.sort}). Isso demonstra o domínio sobre a lógica algorítmica e permite um controle refinado sobre o comportamento do sistema.

\subsection{Método de Ordenação: Quick Sort}
Para a etapa de pré-processamento (essencial para o algoritmo Guloso e organizacional para o DP), implementamos o algoritmo \textbf{Quick Sort}.

\textbf{Justificativa da Escolha:}
Optamos pelo Quick Sort em detrimento de algoritmos mais simples como Bubble Sort ou Insertion Sort ($O(n^2)$) devido à sua eficiência média de $O(n \log n)$. Em um sistema de escalonamento real, onde o número de tarefas pode ser grande, a eficiência da ordenação é crucial para não se tornar um gargalo antes mesmo do processo de seleção começar. O critério de ordenação foi a \textbf{Densidade} ($\frac{\text{Prioridade}}{\text{Tempo} \times (\text{Prazo}+1)}$), ordenando as tarefas da mais "lucrativa" para a menos lucrativa.

\subsection{Interface Humano-Computador (IHC)}
O sistema foi desenvolvido com uma interface baseada em terminal (CLI - Command Line Interface).
\textbf{Justificativa:} A escolha por uma interface textual permite foco total na lógica algorítmica e na visualização clara dos dados de saída (tabelas de comparação), sem o overhead de processamento gráfico. A saída é organizada e explicativa, facilitando a análise imediata dos resultados pelo operador.

\section{Estratégias Algorítmicas Implementadas}

\subsection{Abordagem Gulosa: A Heurística da Densidade}
Para o algoritmo guloso, não basta ordenar por valor ou por tempo. Desenvolvemos uma métrica composta denominada **Densidade**, que equilibra valor, custo e urgência:

$$ \text{Densidade}_i = \frac{v_i}{t_i \times (d_i + 1)} $$

Esta fórmula prioriza tarefas que entregam muito valor rapidamente e que possuem prazos apertados. A implementação utiliza o \textbf{Quick Sort} para ordenar as tarefas decrescentemente por esta densidade e, em seguida, itera linearmente selecionando as que cabem no tempo restante.

\subsection{Abordagem Exata: Programação Dinâmica (Knapsack)}
Modelamos o problema como uma variação do **Problema da Mochila 0/1**, onde a "capacidade da mochila" é o tempo total disponível $T$. A Programação Dinâmica (DP) constrói uma solução passo-a-passo, garantindo que nenhuma combinação de tarefas que resulte em um valor total maior seja ignorada. Ao contrário do guloso, o DP consegue "ver o futuro" e preencher lacunas de tempo com combinações perfeitas de tarefas menores.

\section{Documento Analítico}

\subsection{Formulação do Problema}
Seja um conjunto de $n$ tarefas, onde cada tarefa $i$ tem um peso $w_i$ (tempo) e um valor $v_i$ (prioridade). Seja $W$ a capacidade total.
Queremos maximizar $\sum v_i$ sujeito a $\sum w_i \leq W$.

\subsection{Modelo de Solução (Programação Dinâmica)}
Definimos $dp[i][w]$ como o valor máximo considerando as primeiras $i$ tarefas com capacidade $w$.
$$
dp[i][w] = \max(dp[i-1][w], v_i + dp[i-1][w - w_i]) \quad \text{se } w_i \leq w
$$

\section{Análise Assintótica e Implementação}

A seguir, detalhamos a complexidade teórica corroborada por trechos do código fonte desenvolvido.

\subsection{Escalonador Guloso}
A complexidade é dominada pela ordenação. Utilizamos o Quick Sort, que possui caso médio $O(n \log n)$. A seleção subsequente é linear $O(n)$.

\begin{lstlisting}[language=Java, caption=Partition do Quick Sort (Ordenação por Densidade)]
private int partition(List<Tarefa> tarefas, int low, int high) {
    Tarefa pivot = tarefas.get(high);
    double pivotDensity = pivot.getDensidade();
    int i = (low - 1);
    for (int j = low; j < high; j++) {
        // Ordena decrescente pela densidade calculada
        if (tarefas.get(j).getDensidade() > pivotDensity) {
            i++;
            swap(tarefas, i, j);
        }
    }
    swap(tarefas, i + 1, high);
    return i + 1;
}
\end{lstlisting}

\subsection{Escalonador DP (Knapsack)}
A complexidade é pseudo-polinomial $O(n \cdot W)$, onde $n$ é o número de tarefas e $W$ é o tempo total disponível. Isso ocorre devido à estrutura de laços aninhados necessária para preencher a tabela de memorização.

\begin{lstlisting}[language=Java, caption=Núcleo da Programação Dinâmica]
// n = tarefas.size(), T = tempoTotalDisponivel
for (int i = 1; i <= n; i++) {
    int tempoTarefa = tarefas.get(i-1).getTempo();
    int valorTarefa = tarefas.get(i-1).getPrioridade();
    
    for (int t = 1; t <= T; t++) {
        // Opcao 1: Nao incluir
        dp[i][t] = dp[i-1][t];
        
        // Opcao 2: Incluir se couber
        if (tempoTarefa <= t) {
            int valorCom = dp[i-1][t-tempoTarefa] + valorTarefa;
            if (valorCom > dp[i][t]) {
                dp[i][t] = valorCom;
            }
        }
    }
}
\end{lstlisting}

\section{Análise de Desempenho Experimental}

Realizamos testes empíricos comparando as duas abordagens.

\subsection{Resultados Obtidos}

\begin{table}[H]
\centering
\caption{Comparativo de Valor Total e Tempo de Execução}
\label{tab:resultados}
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Cenário} & \textbf{Algoritmo} & \textbf{Valor Total} & \textbf{Tempo Usado} & \textbf{Execução (ms)} \\ \midrule
1. Favorável & Guloso & 37 & 10 & $\approx 0.15$ \\
(Limite: 10) & DP & 37 & 10 & $\approx 0.20$ \\ \midrule
2. Guloso Falha & Guloso & 11 & 2 & $\approx 0.05$ \\
(Limite: 6) & \textbf{DP} & \textbf{20} & 5 & $\approx 0.10$ \\ \midrule
3. Idênticas & Guloso & 60 & 30 & $\approx 0.08$ \\
(Limite: 30) & DP & 60 & 30 & $\approx 0.15$ \\ \midrule
4. Aleatório & Guloso & 335 & 98 & $\approx 0.16$ \\
(Limite: 100) & \textbf{DP} & \textbf{352} & 100 & $\approx 0.45$ \\ \bottomrule
\end{tabular}
\end{table}

\subsection{Consistência Teórica vs. Empírica}
Os dados da Tabela \ref{tab:resultados} confirmam as expectativas teóricas:

\begin{itemize}
    \item \textbf{Guloso ($O(n \log n)$)}: O tempo de execução manteve-se extremamente baixo e estável ($\approx 0.05$ms a $0.16$ms), pois depende apenas do número de tarefas ($n$), que é pequeno nos testes.
    \item \textbf{DP ($O(n \cdot W)$)}: O tempo de execução aumentou visivelmente no Cenário 4 ($\approx 0.45$ms). Isso ocorre porque o limite de tempo ($W$) aumentou para 100, forçando a matriz $dp$ a ser maior ($n \times 100$) e exigindo mais iterações do laço interno.
\end{itemize}

A "falha" do Guloso no Cenário 2 (Valor 11 vs 20 do DP) ilustra perfeitamente a limitação teórica da heurística: ao escolher uma tarefa densa mas que consome muito tempo, ele bloqueou a inserção de múltiplas tarefas menores que, somadas, valeriam mais. O DP, explorando todas as combinações na matriz, evitou essa armadilha.

\section{Análise Crítica Final}

\subsection{Adequação da Abordagem}
\textbf{Por que a abordagem escolhida foi a ideal?}
A escolha pela Programação Dinâmica foi ideal porque, no contexto de gerenciamento de tarefas críticas, a perda de valor (prioridade) é inaceitável. O algoritmo Guloso, apesar de rápido, falhou em maximizar o uso dos recursos em cenários de "mochila cheia", deixando lacunas de tempo que poderiam ser preenchidas por tarefas mais valiosas. O DP preencheu essas lacunas perfeitamente.

\subsection{Metodologia e Trabalho em Equipe}
\textbf{Como o trabalho em equipe e a metodologia ágil influenciaram?}
O desenvolvimento seguiu uma abordagem incremental. Inicialmente, focamos na implementação da estrutura básica (`Tarefa`) e do algoritmo Guloso para ter um MVP (Minimum Viable Product). Em seguida, implementamos o DP para comparação. A divisão clara de responsabilidades (implementação de algoritmos vs. infraestrutura de testes) e o uso de testes automatizados (`Comparador`) permitiram identificar rapidamente as falhas do algoritmo Guloso, guiando a decisão final de recomendar o DP.

\section{Conclusão}

A implementação do algoritmo \textit{Knapsack} via Programação Dinâmica, suportada por uma ordenação eficiente \textit{Quick Sort}, provou ser a solução superior. O sistema atende a todos os requisitos de otimização, robustez e implementação manual, garantindo o melhor desempenho possível para o centro de processamento de dados.

\end{document}
